using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.IO;                // file operations
using System.Drawing;           // make pictures
using System.Drawing.Imaging;   // image formats

using NChordLib;                // for NChord operations, etc.

namespace ChordTopoMapSample
{
    /// <summary>
    /// This is a sample program that can be used to understand how NChord works.  This program assumes that
    /// an active, existing ring of NChord nodes exists already.  We use the NChord API to talk to nodes in the
    /// NChord ring, ultimately generating a map of that ring (comprised of a list of all of the NodeIDs that
    /// exist in the ring).  Given the map of the ring, a "Topographic Map" (see http://www.cencini.com/ChordTopoMaps)
    /// can be generated by gathering routing hop counts from every node in the ring to every other node in the ring.
    /// This data is translated into a JPG image or output as a CSV file.
    /// </summary>
    class Program
    {
        //
        // Constants
        //

        /// <summary>
        /// The maximum number of unique nodes to map before halting (to keep processing/resource
        /// utilitzation from going completely out of control).
        /// </summary>
        private const int MaxNodeLimit = 6000;

        /// <summary>
        /// Main program body.
        /// </summary>
        /// <param name="args">Arguments.  Format assumed is:
        //     ChordTopoMap.exe {-csv | -jpg} <outputFile> <hostname> <port>
        /// </param>
        static void Main(string[] args)
        {
            if (args != null && args.Length == 4)
            {
                // set up the seed node, and generate the internal nodelist and map
                ChordNode seedNode = new ChordNode(args[2], Convert.ToInt32(args[3]));
                int[,] hopCountMap;
                List<ChordNode> nodeList;
                GenerateMap(seedNode, out nodeList, out hopCountMap);

                if (args[0].ToLower() == "-csv")
                {
                    GenerateCsv(hopCountMap, nodeList, args[1]);
                }
                else if (args[0].ToLower() == "-jpg")
                {
                    GenerateImage(hopCountMap, nodeList, args[1]);
                }
            }
            else
            {
                // invalid input, print usage
                PrintUsage();
            }
        }

        /// <summary>
        /// Print usage information about the command-line utility.
        /// </summary>
        private static void PrintUsage()
        {
            Console.WriteLine("\nUsage:  ChordTopoMap.exe {-csv | -jpg} <outputFile> <hostname> <port>");
            Console.WriteLine("  -csv : Output results as a CSV file, named <outputFile>");
            Console.WriteLine("  -jpg : Output results as a JPG file, named <outputFile>");
            Console.WriteLine("  <hostname> : The hostname of the NChord node to use as seed node.");
            Console.WriteLine("  <port> : The TCP port number of the NChord node to use as seed node.\n");
        }

        //
        // Shared functionality
        //
        #region Shared Functionality

        /// <summary>
        /// Given a starting node for a valid Chord ring, gather the list of all nodes in the ring,
        /// and get the hopcount map from each node to each other node in the system.
        /// </summary>
        /// <param name="seedNode">The starting node in a valid Chord ring.</param>
        /// <param name="nodeList">The list of Chord nodes in the ring.  This list is already sorted.</param>
        /// <param name="hopcountMap">An N x N matrix of hopcounts where x=y=nodeList.Count.</param>
        private static void GenerateMap(ChordNode seedNode, out List<ChordNode> nodeList, out int[,] hopcountMap)
        {
            // first get the list of all of the nodes in the system
            nodeList = GetNodeList(seedNode);

            // set up the hopcountMap to be an N x N matrix where N is the number of nodes in the ring.
            hopcountMap = new int[nodeList.Count, nodeList.Count];

            // now, for each node in the nodelist, measure FindSuccessor() hopcounts to each other node in
            // the nodelist, and store them in the hopcount map.
            //
            // NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
            //
            //  Obviously, this can (and should) be multithreaded for any reasonably large system.  I've
            //  only made this sample program single-threaded for readability.  Translating from a single-
            //  threaded implementation to a multithreaded implementation of the style of the developer's
            //  choice should be considered a reasonable enough task for anyone experimenting more than casually
            //  with NChord (beyond a few thousand nodes).
            //

            // sort the nodelist by nodeId (ChordNode implements IComparable and compares on the Node ID value).
            nodeList.Sort();

            // now, go to each node, and have it call FindSuccessor on that nodeId, and hold on to the hopCount
            // by storing it in the hopCountmap at the appropriate position
            
            int y = 0;  // the "row" offset in hopcountMap
            foreach (ChordNode sourceNode in nodeList)
            {
                int x = 0;  // the "column" offset in hopcountMap

                // get hopcount from the sourceNode to each destinationNode
                foreach (ChordNode destinationNode in nodeList)
                {
                    // CallFindSuccessor connects to sourceNode and calls FindSuccessor for the destination node's
                    // ID.  3 retries (in case of communication failure, etc.) should be more than sufficient.
                    // since we are the initiating node, pass in a value of 0 as the starting hopcount, and store
                    // the resultant hopcount in the appropriate place in the hopcountMap.
                    ChordServer.CallFindSuccessor(sourceNode, destinationNode.ID, 3, 0, out hopcountMap[y, x]);
                    
                    x++;    // move to the next column in the row
                }
                y++;    // move to the next row in the map
            }

            // there you go, you have a hopcount map
        }

        /// <summary>
        /// Get the list of all of the nodes in a Chord ring by starting at seedNode
        /// and following the successor chain around the ring.  There are better ways
        /// to do this, though churn can almost always screw things up in generating a
        /// map of what would ideally represent flawlessly the state of the entire 
        /// distributed system at a single given point in time.  Realizing that the world
        /// is not a perfect place can provide great peace at times - you just do the
        /// best you can and accept imperfection.  That's what we do here.
        /// </summary>
        /// <param name="seedNode">The node to start collecting the list of nodes in the ring from.</param>
        /// <returns>A list of nodes in the Chord ring.</returns>
        private static List<ChordNode> GetNodeList(ChordNode seedNode)
        {
            List<ChordNode> nodeList = new List<ChordNode>();
            nodeList.Add(seedNode);     // don't forget to add the seedNode!

            // the current node (starting with the seed node's successor)
            // as we iterate through the ring.
            ChordNode currNode = ChordServer.GetSuccessor(seedNode);

            int i = 0;  // the number of iterations we have made (so we don't loop infinitely)
            while (seedNode.ID != currNode.ID && i < MaxNodeLimit)
            {
                // get my successor and add it to the nodeList.
                // eventually, my successor will be the seedNode
                // or i will hit the maximum node limit, at which
                // point i just stop
                currNode = ChordServer.GetSuccessor(currNode);
                nodeList.Add(currNode);
                i++;
            }

            return nodeList;
        }

        #endregion

        //
        // Print CSV
        //
        #region CSV-Printing

        /// <summary>
        /// Output the hop count map to a CSV file.
        /// </summary>
        /// <param name="hopcountMap">The hopcount map to dump to CSV.</param>
        /// <param name="nodeList">The list of nodes used to generate the map.</param>
        /// <param name="outputFilename">The path and filename to output the CSV file to.</param>
        private static void GenerateCsv(int[,] hopcountMap, List<ChordNode> nodeList, string outputFilename)
        {
            StreamWriter fileWriter = File.CreateText(outputFilename);

            // go through each column of each row of the map
            // and output the data a row at a time to the output file
            for (int y = 0; y < nodeList.Count; y++)
            {
                string hopCounts = string.Empty;
                for (int x = 0; x < nodeList.Count; x++)
                {
                    hopCounts += hopcountMap[y, x];
                    if (x != nodeList.Count - 1)
                    {
                        hopCounts += ",";
                    }
                }
                fileWriter.WriteLine(hopCounts);
            }

            fileWriter.Close();
        }

        #endregion

        //
        // Generate Image
        //
        #region Image-Generation

        /// <summary>
        /// Output the hop count map to a JPG file.
        /// </summary>
        /// <param name="hopcountMap">The hopcount map to dump to JPG.</param>
        /// <param name="nodeList">The list of nodes used to generate the map.</param>
        /// <param name="outputFilename">The path and filename to output the CSV file to.</param>
        private static void GenerateImage(int[,] hopcountMap, List<ChordNode> nodeList, string outputFileName)
        {
            // create an N x N bitmap into which the map will be written
            Bitmap mapImage = new Bitmap(nodeList.Count, nodeList.Count);

            for (int y = 0; y < nodeList.Count; y++)
            {
                for (int x = 0; x < nodeList.Count; x++)
                {
                    Color pixelColor = Color.White; // default color in case of error
                    
                    // if we have a color for the given hopcount
                    if (hopcountMap[y, x] <= ColorMap.Length)
                    {
                        // set the color based on the hop count in the map
                        pixelColor = ColorMap[hopcountMap[y, x]];
                    }

                    // set the appropriate pixel to the color representing the hopcount
                    mapImage.SetPixel(x, y, pixelColor);
                }
            }

            mapImage.Save(outputFileName, ImageFormat.Jpeg);
        }

        /// <summary>
        /// The map of colors to use in generating the image. Each item
        /// corresponds to a hop count value - colors may be added or changed here.
        /// </summary>
        private static Color[] ColorMap = 
        {
            Color.Black,                    /* 0  */
            Color.LightGray,                /* 1  */
            Color.Gray,                     /* 2  */
            Color.LightBlue,                /* 3  */
            Color.Blue,                     /* 4  */
            Color.Navy,                     /* 5  */
            Color.LightGreen,               /* 6  */
            Color.Green,                    /* 7  */
            Color.LightYellow,              /* 8  */
            Color.Yellow,                   /* 9  */
            Color.Red,                      /* 10 */
            Color.Maroon,                   /* 11 */
            Color.Purple,                   /* 12 */
            Color.Plum                      /* 13 */
        };

        #endregion
    }
}
