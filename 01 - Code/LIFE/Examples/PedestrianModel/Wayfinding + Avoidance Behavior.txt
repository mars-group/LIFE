Wegfindung in WALK:
- RaytracingGraph (Map von Vector3D und allen Nachbarn) mit Hilfe von RayUtil erstellen 
- AStarPathfinder sucht kürzesten Weg für den Agenten zum Ziel (Liste von Vector3D) auf dem RaytracingGraph
- Agent enthält eine Liste von MoveActions mit Wegpunkten zum Zielpunkt

Ausweichen in WALK:
- ReactiveBehaviorPipeline enthält ReactiveMovingBehaviors, die den Bewegungsvektor der Agenten verändern können, in WALK nur EGOAPObstacleAvoidanceBehavior
- EGOAPObstacleAvoidanceBehavior nutzt Potentiale für die Berechnung der Änderung des Vektors (Zielposition: anziehend, Hindernisse: abstoßend)
- Wenn die MoveActions des Agenten ausgeführt werden, wird zuerst der originale Bewegungsvektor (Richtung und Geschwindigkeit) berechnet
- Dann wird die Bewegungsrichtung unter Einfluss der ReactiveMovingBehaviors verändert
- Es wird eine neue MoveAction erstellt

Bewegung in WALK:
- Die erstellten (und veränderten) MoveActions werden ausgeführt



Wichtigste Klassen:
- EGOAPAgent.java

- RaytracingGraph.java
- RayUtil.java
- AStarPtahfinder

- ReactiveMovingBehavior.java
- ReactiveMovingBehaviorPipeline.java
- EGOAPObstacleAvoidanceBehavior.java
- MoveAction.java

- PotentialField.java
- PointEmitter.java

Externe Klassen:
- org.apache.commons.math.analysis.UnivariateRealFunction (z.B. bei [1])
(https://commons.apache.org/proper/commons-math/javadocs/api-2.2/org/apache/commons/math/analysis/UnivariateRealFunction.html
https://commons.apache.org/proper/commons-math/javadocs/api-2.2/src-html/org/apache/commons/math/analysis/UnivariateRealFunction.html) 
-> müsste sich auch gut selbst umsetzen lassen: Macht nichts anderes, als ein x in eine Gleichung einzusetzen und damit auszurechnen. Hat nur 1 Funktion: double value(double x)
(- org.apache.commons.math.geometry.euclidean.threed.Vector3D)
-> C#/.NET Äquivalente vermutlich nicht nötig



Hilfreiche Tools:
- http://codecall.net/2014/03/27/best-tools-to-convert-java-to-c-source-code/


[1]
private static final UnivariateRealFunction TARGET_DISTANCE_POTENTIAL_FUNCTION = new UnivariateRealFunction() {
        @Override
        public final double value(final double x) {
            if (x == 0.0) {
                return 0.0;
            }
            return 4000 / (x + 1);
        }
    };